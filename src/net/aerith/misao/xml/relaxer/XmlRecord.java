package net.aerith.misao.xml.relaxer;

import org.w3c.dom.*;

/**
 * <b>XmlRecord</b> is generated by Relaxer based on pixy.rlx.
 * This class is derived from:
 * 
 * <!-- for programmer
 * <elementRule role="record">
 *   <sequence>
 *     <element name="name" occurs="?" type="string"/>
 *     <ref label="coor"/>
 *     <ref label="position" occurs="?"/>
 *     <ref label="item" occurs="*"/>
 *   </sequence>
 * </elementRule>
 * 
 * <tag name="record">
 *   <attribute name="class" required="true" type="string"/>
 * </tag>
 * -->
 * <!-- for javadoc -->
 * <pre> &lt;elementRule role="record"&gt;
 *   &lt;sequence&gt;
 *     &lt;element name="name" occurs="?" type="string"/&gt;
 *     &lt;ref label="coor"/&gt;
 *     &lt;ref label="position" occurs="?"/&gt;
 *     &lt;ref label="item" occurs="*"/&gt;
 *   &lt;/sequence&gt;
 * &lt;/elementRule&gt;
 * &lt;tag name="record"&gt;
 *   &lt;attribute name="class" required="true" type="string"/&gt;
 * &lt;/tag&gt;
 * </pre>
 *
 * @version pixy.rlx (Tue Nov 23 19:35:40 JST 2004)
 * @author  Relaxer 0.10.1 (by ASAMI@Yokohama)
 */
public class XmlRecord extends net.aerith.misao.xml.IONode implements java.io.Serializable, IRNode {
    private String classValue;
    private String name;
    private XmlCoor coor;
    private XmlPosition position;
    // List<XmlItem>
    private java.util.List item = new java.util.ArrayList();
    private IRNode parentRNode;
    private RContext rContext;

    /**
     * Creates a <code>XmlRecord</code>.
     *
     */
    public XmlRecord() {
    }

    /**
     * Creates a <code>XmlRecord</code> by the Stack <code>stack</code>
     * that contains Elements.
     * This constructor is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     */
    public XmlRecord(RStack stack) {
        setup(stack);
    }

    /**
     * Creates a <code>XmlRecord</code> by the Document <code>doc</code>.
     *
     * @param doc
     */
    public XmlRecord(Document doc) {
        setup(doc.getDocumentElement());
    }

    /**
     * Creates a <code>XmlRecord</code> by the Element <code>element</code>.
     *
     * @param element
     */
    public XmlRecord(Element element) {
        setup(element);
    }

    /**
     * Initializes the <code>XmlRecord</code> by the Document <code>doc</code>.
     *
     * @param doc
     */
    public void setup(Document doc) {
        setup(doc.getDocumentElement());
    }

    /**
     * Initializes the <code>XmlRecord</code> by the Element <code>element</code>.
     *
     * @param element
     */
    public void setup(Element element) {
        init(element);
    }

    /**
     * Initializes the <code>XmlRecord</code> by the Stack <code>stack</code>
     * that contains Elements.
     * This constructor is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     */
    public void setup(RStack stack) {
        setup(stack.popElement());
    }

    /**
     * @param element
     */
    private void init(Element element) {
        IPixyFactory factory = PixyFactory.getFactory();
        RStack stack = new RStack(element);
        classValue = URelaxer.getAttributePropertyAsString(element, "class");
        name = URelaxer.getElementPropertyAsStringByStack(stack, "name");
        setCoor(factory.createXmlCoor(stack));
        if (XmlPosition.isMatch(stack)) {
            setPosition(factory.createXmlPosition(stack));
        }
        item.clear();
        while (!stack.isEmptyElement()) {
            if (XmlItem.isMatch(stack)) {
                addItem(factory.createXmlItem(stack));
            } else {
                break;
            }
        }
    }

    /**
     * Creates a DOM representation of the object.
     * Result is appended to the Node <code>parent</code>.
     *
     * @param parent
     */
    public void makeElement(Node parent) {
        Document doc;
        if (parent instanceof Document) {
            doc = (Document)parent;
        } else {
            doc = parent.getOwnerDocument();
        }
        Element element = doc.createElement("record");
        int size;
        URelaxer.setAttributePropertyByString(element, "class", classValue);
        if (name != null) {
            URelaxer.setElementPropertyByString(element, "name", name);
        }
        coor.makeElement(element);
        if (position != null) {
            position.makeElement(element);
        }
        size = item.size();
        for (int i = 0;i < size;i++) {
            XmlItem value = (XmlItem)this.item.get(i);
            value.makeElement(element);
        }
        parent.appendChild(element);
    }

    /**
     * Gets the String property <b>classValue</b>.
     *
     * @return String
     */
    public final String getClassValue() {
        return (classValue);
    }

    /**
     * Sets the String property <b>classValue</b>.
     *
     * @param classValue
     */
    public final void setClassValue(String classValue) {
        this.classValue = classValue;
    }

    /**
     * Gets the String property <b>name</b>.
     *
     * @return String
     */
    public final String getName() {
        return (name);
    }

    /**
     * Sets the String property <b>name</b>.
     *
     * @param name
     */
    public final void setName(String name) {
        this.name = name;
    }

    /**
     * Gets the XmlCoor property <b>coor</b>.
     *
     * @return XmlCoor
     */
    public final XmlCoor getCoor() {
        return (coor);
    }

    /**
     * Sets the XmlCoor property <b>coor</b>.
     *
     * @param coor
     */
    public final void setCoor(XmlCoor coor) {
        this.coor = coor;
        coor.setParentRNode(this);
    }

    /**
     * Gets the XmlPosition property <b>position</b>.
     *
     * @return XmlPosition
     */
    public final XmlPosition getPosition() {
        return (position);
    }

    /**
     * Sets the XmlPosition property <b>position</b>.
     *
     * @param position
     */
    public final void setPosition(XmlPosition position) {
        this.position = position;
		if (position != null)
			position.setParentRNode(this);
    }

    /**
     * Gets the XmlItem property <b>item</b>.
     *
     * @return XmlItem[]
     */
    public final XmlItem[] getItem() {
        IPixyFactory factory = PixyFactory.getFactory();
        XmlItem[] array = factory.createArrayXmlItem(item.size());
        return ((XmlItem[])item.toArray(array));
    }

    /**
     * Sets the XmlItem property <b>item</b>.
     *
     * @param item
     */
    public final void setItem(XmlItem[] item) {
        this.item.clear();
        this.item.addAll(java.util.Arrays.asList(item));
        for (int i = 0;i < item.length;i++) {
            item[i].setParentRNode(this);
        }
    }

    /**
     * Adds the XmlItem property <b>item</b>.
     *
     * @param item
     */
    public final void addItem(XmlItem item) {
        this.item.add(item);
        item.setParentRNode(this);
    }

    /**
     * Gets the IRNode property <b>parentRNode</b>.
     *
     * @return IRNode
     */
    public final IRNode getParentRNode() {
        return (parentRNode);
    }

    /**
     * Sets the IRNode property <b>parentRNode</b>.
     *
     * @param parentRNode
     */
    public final void setParentRNode(IRNode parentRNode) {
        this.parentRNode = parentRNode;
    }

    /**
     * Gets child RNodes.
     *
     * @return IRNode[]
     */
    public IRNode[] getRNodes() {
        java.util.List classNodes = new java.util.ArrayList();
        classNodes.add(coor);
        if (position != null) {
            classNodes.add(position);
        }
        classNodes.addAll(item);
        IRNode[] nodes = new IRNode[classNodes.size()];
        return ((IRNode[])classNodes.toArray(nodes));
    }

    /**
     * Gets the RContext property <b>rContext</b>.
     *
     * @return RContext
     */
    public final RContext getRContext() {
        return (rContext);
    }

    /**
     * Sets the RContext property <b>rContext</b>.
     *
     * @param rContext
     */
    public final void setRContext(RContext rContext) {
        this.rContext = rContext;
        IRNode[] contextRNodes = getRNodes();
        for (int i = 0;i < contextRNodes.length;i++) {
            contextRNodes[i].setRContext(rContext);
        }
    }

    /**
     * Gets the property "rContext" which is resolved recursively.
     *
     * @return RContext
     */
    public RContext getRContextResolved() {
        if (rContext != null) {
            return (rContext);
        }
        if (parentRNode == null) {
            return (null);
        }
        return (parentRNode.getRContextResolved());
    }

    /**
     * Tests if a Element <code>element</code> is valid
     * for the <code>XmlRecord</code>.
     *
     * @param element
     * @return boolean
     */
    public static boolean isMatch(Element element) {
        String tagName = element.getTagName();
        if (!"record".equals(tagName)) {
            return (false);
        }
        RStack target = new RStack(element);
        Element child;
        child = target.peekElement();
        if (child != null) {
            if ("name".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (!XmlCoor.isMatchHungry(target)) {
            return (false);
        }
        if (XmlPosition.isMatchHungry(target)) {
        }
        while (!target.isEmptyElement()) {
            if (!XmlItem.isMatchHungry(target)) {
                break;
            }
        }
        if (!target.isEmptyElement()) {
            return (false);
        }
        return (true);
    }

    /**
     * Tests if elements contained in a Stack <code>stack</code>
     * is valid for the <code>XmlRecord</code>.
     * This mehtod is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     * @return boolean
     */
    public static boolean isMatch(RStack stack) {
        Element element = stack.peekElement();
        if (element == null) {
            return (false);
        }
        return (isMatch(element));
    }

    /**
     * Tests if elements contained in a Stack <code>stack</code>
     * is valid for the <code>XmlRecord</code>.
     * This method consumes the stack contents during matching operation.
     * This mehtod is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     * @return boolean
     */
    public static boolean isMatchHungry(RStack stack) {
        Element element = stack.peekElement();
        if (element == null) {
            return (false);
        }
        if (isMatch(element)) {
            stack.popElement();
            return (true);
        } else {
            return (false);
        }
    }
}
