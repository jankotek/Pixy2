package net.aerith.misao.xml.relaxer;

import org.w3c.dom.*;

/**
 * <b>XmlInformation</b> is generated by Relaxer based on pixy.rlx.
 * This class is derived from:
 * 
 * <!-- for programmer
 * <elementRule role="information">
 *   <sequence>
 *     <element name="path" occurs="?" type="string"/>
 *     <ref label="image"/>
 *     <ref label="size"/>
 *     <ref label="date" occurs="?"/>
 *     <ref label="exposure" occurs="?"/>
 *     <element name="observer" occurs="?" type="string"/>
 *     <ref label="center"/>
 *     <ref label="fov"/>
 *     <ref label="rotation"/>
 *     <ref label="pixel-size"/>
 *     <element name="limiting-mag" type="float"/>
 *     <element name="upper-limit-mag" occurs="?" type="float"/>
 *     <ref label="astrometric-error" occurs="?"/>
 *     <element name="photometric-error" occurs="?" type="float"/>
 *     <element name="magnitude-translation-formula" occurs="?" type="string"/>
 *     <element name="magnitude-correction" occurs="?" type="string"/>
 *     <ref label="distortion-field" occurs="?"/>
 *     <element name="filter" occurs="?" type="string"/>
 *     <element name="chip" occurs="?" type="string"/>
 *     <element name="instruments" occurs="?" type="string"/>
 *     <element name="base-catalog" type="string"/>
 *     <ref label="astrometry" occurs="?"/>
 *     <ref label="photometry" occurs="?"/>
 *     <ref label="reversed-image" occurs="?"/>
 *     <ref label="sbig-image" occurs="?"/>
 *     <ref label="unofficial" occurs="?"/>
 *     <ref label="star-count" occurs="?"/>
 *     <element name="note" occurs="?" type="string"/>
 *   </sequence>
 * </elementRule>
 * 
 * <tag name="information"/>
 * -->
 * <!-- for javadoc -->
 * <pre> &lt;elementRule role="information"&gt;
 *   &lt;sequence&gt;
 *     &lt;element name="path" occurs="?" type="string"/&gt;
 *     &lt;ref label="image"/&gt;
 *     &lt;ref label="size"/&gt;
 *     &lt;ref label="date" occurs="?"/&gt;
 *     &lt;ref label="exposure" occurs="?"/&gt;
 *     &lt;element name="observer" occurs="?" type="string"/&gt;
 *     &lt;ref label="center"/&gt;
 *     &lt;ref label="fov"/&gt;
 *     &lt;ref label="rotation"/&gt;
 *     &lt;ref label="pixel-size"/&gt;
 *     &lt;element name="limiting-mag" type="float"/&gt;
 *     &lt;element name="upper-limit-mag" occurs="?" type="float"/&gt;
 *     &lt;ref label="astrometric-error" occurs="?"/&gt;
 *     &lt;element name="photometric-error" occurs="?" type="float"/&gt;
 *     &lt;element name="magnitude-translation-formula" occurs="?" type="string"/&gt;
 *     &lt;element name="magnitude-correction" occurs="?" type="string"/&gt;
 *     &lt;ref label="distortion-field" occurs="?"/&gt;
 *     &lt;element name="filter" occurs="?" type="string"/&gt;
 *     &lt;element name="chip" occurs="?" type="string"/&gt;
 *     &lt;element name="instruments" occurs="?" type="string"/&gt;
 *     &lt;element name="base-catalog" type="string"/&gt;
 *     &lt;ref label="astrometry" occurs="?"/&gt;
 *     &lt;ref label="photometry" occurs="?"/&gt;
 *     &lt;ref label="reversed-image" occurs="?"/&gt;
 *     &lt;ref label="sbig-image" occurs="?"/&gt;
 *     &lt;ref label="unofficial" occurs="?"/&gt;
 *     &lt;ref label="star-count" occurs="?"/&gt;
 *     &lt;element name="note" occurs="?" type="string"/&gt;
 *   &lt;/sequence&gt;
 * &lt;/elementRule&gt;
 * &lt;tag name="information"/&gt;
 * </pre>
 *
 * @version pixy.rlx (Tue Nov 23 20:34:01 JST 2004)
 * @author  Relaxer 0.10.1 (by ASAMI@Yokohama)
 */
public class XmlInformation extends net.aerith.misao.xml.IONode implements java.io.Serializable, IRNode {
    private String path;
    private XmlImage image;
    private XmlSize sizeValue;
    private String date;
    private XmlExposure exposure;
    private String observer;
    private XmlCenter center;
    private XmlFov fov;
    private XmlRotation rotation;
    private XmlPixelSize pixelSize;
    private float limitingMag;
    private Float upperLimitMag;
    private XmlAstrometricError astrometricError;
    private Float photometricError;
    private String magnitudeTranslationFormula;
    private String magnitudeCorrection;
    private XmlDistortionField distortionField;
    private String filter;
    private String chip;
    private String instruments;
    private String baseCatalog;
    private XmlAstrometry astrometry;
    private XmlPhotometry photometry;
    private XmlReversedImage reversedImage;
    private XmlSbigImage sbigImage;
    private XmlUnofficial unofficial;
    private XmlStarCount starCount;
    private String note;
    private IRNode parentRNode;
    private RContext rContext;

    /**
     * Creates a <code>XmlInformation</code>.
     *
     */
    public XmlInformation() {
    }

    /**
     * Creates a <code>XmlInformation</code> by the Stack <code>stack</code>
     * that contains Elements.
     * This constructor is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     */
    public XmlInformation(RStack stack) {
        setup(stack);
    }

    /**
     * Creates a <code>XmlInformation</code> by the Document <code>doc</code>.
     *
     * @param doc
     */
    public XmlInformation(Document doc) {
        setup(doc.getDocumentElement());
    }

    /**
     * Creates a <code>XmlInformation</code> by the Element <code>element</code>.
     *
     * @param element
     */
    public XmlInformation(Element element) {
        setup(element);
    }

    /**
     * Initializes the <code>XmlInformation</code> by the Document <code>doc</code>.
     *
     * @param doc
     */
    public void setup(Document doc) {
        setup(doc.getDocumentElement());
    }

    /**
     * Initializes the <code>XmlInformation</code> by the Element <code>element</code>.
     *
     * @param element
     */
    public void setup(Element element) {
        init(element);
    }

    /**
     * Initializes the <code>XmlInformation</code> by the Stack <code>stack</code>
     * that contains Elements.
     * This constructor is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     */
    public void setup(RStack stack) {
        setup(stack.popElement());
    }

    /**
     * @param element
     */
    private void init(Element element) {
        IPixyFactory factory = PixyFactory.getFactory();
        RStack stack = new RStack(element);
        path = URelaxer.getElementPropertyAsStringByStack(stack, "path");
        setImage(factory.createXmlImage(stack));
        setSize(factory.createXmlSize(stack));
        date = URelaxer.getElementPropertyAsStringByStack(stack, "date");
        if (XmlExposure.isMatch(stack)) {
            setExposure(factory.createXmlExposure(stack));
        }
        observer = URelaxer.getElementPropertyAsStringByStack(stack, "observer");
        setCenter(factory.createXmlCenter(stack));
        setFov(factory.createXmlFov(stack));
        setRotation(factory.createXmlRotation(stack));
        setPixelSize(factory.createXmlPixelSize(stack));
        limitingMag = URelaxer.getElementPropertyAsFloat(stack.popElement());
        upperLimitMag = URelaxer.getElementPropertyAsFloatByStack(stack, "upper-limit-mag");
        if (XmlAstrometricError.isMatch(stack)) {
            setAstrometricError(factory.createXmlAstrometricError(stack));
        }
        photometricError = URelaxer.getElementPropertyAsFloatByStack(stack, "photometric-error");
        magnitudeTranslationFormula = URelaxer.getElementPropertyAsStringByStack(stack, "magnitude-translation-formula");
        magnitudeCorrection = URelaxer.getElementPropertyAsStringByStack(stack, "magnitude-correction");
        if (XmlDistortionField.isMatch(stack)) {
            setDistortionField(factory.createXmlDistortionField(stack));
        }
        filter = URelaxer.getElementPropertyAsStringByStack(stack, "filter");
        chip = URelaxer.getElementPropertyAsStringByStack(stack, "chip");
        instruments = URelaxer.getElementPropertyAsStringByStack(stack, "instruments");
        baseCatalog = URelaxer.getElementPropertyAsString(stack.popElement());
        if (XmlAstrometry.isMatch(stack)) {
            setAstrometry(factory.createXmlAstrometry(stack));
        }
        if (XmlPhotometry.isMatch(stack)) {
            setPhotometry(factory.createXmlPhotometry(stack));
        }
        if (XmlReversedImage.isMatch(stack)) {
            setReversedImage(factory.createXmlReversedImage(stack));
        }
        if (XmlSbigImage.isMatch(stack)) {
            setSbigImage(factory.createXmlSbigImage(stack));
        }
        if (XmlUnofficial.isMatch(stack)) {
            setUnofficial(factory.createXmlUnofficial(stack));
        }
        if (XmlStarCount.isMatch(stack)) {
            setStarCount(factory.createXmlStarCount(stack));
        }
        note = URelaxer.getElementPropertyAsStringByStack(stack, "note");
    }

    /**
     * Creates a DOM representation of the object.
     * Result is appended to the Node <code>parent</code>.
     *
     * @param parent
     */
    public void makeElement(Node parent) {
        Document doc;
        if (parent instanceof Document) {
            doc = (Document)parent;
        } else {
            doc = parent.getOwnerDocument();
        }
        Element element = doc.createElement("information");
        int size;
        if (path != null) {
            URelaxer.setElementPropertyByString(element, "path", path);
        }
        image.makeElement(element);
        sizeValue.makeElement(element);
        if (date != null) {
            URelaxer.setElementPropertyByString(element, "date", date);
        }
        if (exposure != null) {
            exposure.makeElement(element);
        }
        if (observer != null) {
            URelaxer.setElementPropertyByString(element, "observer", observer);
        }
        center.makeElement(element);
        fov.makeElement(element);
        rotation.makeElement(element);
        pixelSize.makeElement(element);
        URelaxer.setElementPropertyByFloat(element, "limiting-mag", limitingMag);
        if (upperLimitMag != null) {
            URelaxer.setElementPropertyByFloat(element, "upper-limit-mag", upperLimitMag);
        }
        if (astrometricError != null) {
            astrometricError.makeElement(element);
        }
        if (photometricError != null) {
            URelaxer.setElementPropertyByFloat(element, "photometric-error", photometricError);
        }
        if (magnitudeTranslationFormula != null) {
            URelaxer.setElementPropertyByString(element, "magnitude-translation-formula", magnitudeTranslationFormula);
        }
        if (magnitudeCorrection != null) {
            URelaxer.setElementPropertyByString(element, "magnitude-correction", magnitudeCorrection);
        }
        if (distortionField != null) {
            distortionField.makeElement(element);
        }
        if (filter != null) {
            URelaxer.setElementPropertyByString(element, "filter", filter);
        }
        if (chip != null) {
            URelaxer.setElementPropertyByString(element, "chip", chip);
        }
        if (instruments != null) {
            URelaxer.setElementPropertyByString(element, "instruments", instruments);
        }
        URelaxer.setElementPropertyByString(element, "base-catalog", baseCatalog);
        if (astrometry != null) {
            astrometry.makeElement(element);
        }
        if (photometry != null) {
            photometry.makeElement(element);
        }
        if (reversedImage != null) {
            reversedImage.makeElement(element);
        }
        if (sbigImage != null) {
            sbigImage.makeElement(element);
        }
        if (unofficial != null) {
            unofficial.makeElement(element);
        }
        if (starCount != null) {
            starCount.makeElement(element);
        }
        if (note != null) {
            URelaxer.setElementPropertyByString(element, "note", note);
        }
        parent.appendChild(element);
    }

    /**
     * Gets the String property <b>path</b>.
     *
     * @return String
     */
    public final String getPath() {
        return (path);
    }

    /**
     * Sets the String property <b>path</b>.
     *
     * @param path
     */
    public final void setPath(String path) {
        this.path = path;
    }

    /**
     * Gets the XmlImage property <b>image</b>.
     *
     * @return XmlImage
     */
    public final XmlImage getImage() {
        return (image);
    }

    /**
     * Sets the XmlImage property <b>image</b>.
     *
     * @param image
     */
    public final void setImage(XmlImage image) {
        this.image = image;
        image.setParentRNode(this);
    }

    /**
     * Gets the XmlSize property <b>size</b>.
     *
     * @return XmlSize
     */
    public final XmlSize getSize() {
        return (sizeValue);
    }

    /**
     * Sets the XmlSize property <b>size</b>.
     *
     * @param sizeValue
     */
    public final void setSize(XmlSize sizeValue) {
        this.sizeValue = sizeValue;
        sizeValue.setParentRNode(this);
    }

    /**
     * Gets the String property <b>date</b>.
     *
     * @return String
     */
    public final String getDate() {
        return (date);
    }

    /**
     * Sets the String property <b>date</b>.
     *
     * @param date
     */
    public final void setDate(String date) {
        this.date = date;
    }

    /**
     * Gets the XmlExposure property <b>exposure</b>.
     *
     * @return XmlExposure
     */
    public final XmlExposure getExposure() {
        return (exposure);
    }

    /**
     * Sets the XmlExposure property <b>exposure</b>.
     *
     * @param exposure
     */
    public final void setExposure(XmlExposure exposure) {
        this.exposure = exposure;
        exposure.setParentRNode(this);
    }

    /**
     * Gets the String property <b>observer</b>.
     *
     * @return String
     */
    public final String getObserver() {
        return (observer);
    }

    /**
     * Sets the String property <b>observer</b>.
     *
     * @param observer
     */
    public final void setObserver(String observer) {
        this.observer = observer;
    }

    /**
     * Gets the XmlCenter property <b>center</b>.
     *
     * @return XmlCenter
     */
    public final XmlCenter getCenter() {
        return (center);
    }

    /**
     * Sets the XmlCenter property <b>center</b>.
     *
     * @param center
     */
    public final void setCenter(XmlCenter center) {
        this.center = center;
        center.setParentRNode(this);
    }

    /**
     * Gets the XmlFov property <b>fov</b>.
     *
     * @return XmlFov
     */
    public final XmlFov getFov() {
        return (fov);
    }

    /**
     * Sets the XmlFov property <b>fov</b>.
     *
     * @param fov
     */
    public final void setFov(XmlFov fov) {
        this.fov = fov;
        fov.setParentRNode(this);
    }

    /**
     * Gets the XmlRotation property <b>rotation</b>.
     *
     * @return XmlRotation
     */
    public final XmlRotation getRotation() {
        return (rotation);
    }

    /**
     * Sets the XmlRotation property <b>rotation</b>.
     *
     * @param rotation
     */
    public final void setRotation(XmlRotation rotation) {
        this.rotation = rotation;
        rotation.setParentRNode(this);
    }

    /**
     * Gets the XmlPixelSize property <b>pixelSize</b>.
     *
     * @return XmlPixelSize
     */
    public final XmlPixelSize getPixelSize() {
        return (pixelSize);
    }

    /**
     * Sets the XmlPixelSize property <b>pixelSize</b>.
     *
     * @param pixelSize
     */
    public final void setPixelSize(XmlPixelSize pixelSize) {
        this.pixelSize = pixelSize;
        pixelSize.setParentRNode(this);
    }

    /**
     * Gets the float property <b>limitingMag</b>.
     *
     * @return float
     */
    public final float getLimitingMag() {
        return (limitingMag);
    }

    /**
     * Sets the float property <b>limitingMag</b>.
     *
     * @param limitingMag
     */
    public final void setLimitingMag(float limitingMag) {
        this.limitingMag = limitingMag;
    }

    /**
     * Gets the Float property <b>upperLimitMag</b>.
     *
     * @return Float
     */
    public final Float getUpperLimitMag() {
        return (upperLimitMag);
    }

    /**
     * Sets the Float property <b>upperLimitMag</b>.
     *
     * @param upperLimitMag
     */
    public final void setUpperLimitMag(Float upperLimitMag) {
        this.upperLimitMag = upperLimitMag;
    }

    /**
     * Gets the XmlAstrometricError property <b>astrometricError</b>.
     *
     * @return XmlAstrometricError
     */
    public final XmlAstrometricError getAstrometricError() {
        return (astrometricError);
    }

    /**
     * Sets the XmlAstrometricError property <b>astrometricError</b>.
     *
     * @param astrometricError
     */
    public final void setAstrometricError(XmlAstrometricError astrometricError) {
        this.astrometricError = astrometricError;
        astrometricError.setParentRNode(this);
    }

    /**
     * Gets the Float property <b>photometricError</b>.
     *
     * @return Float
     */
    public final Float getPhotometricError() {
        return (photometricError);
    }

    /**
     * Sets the Float property <b>photometricError</b>.
     *
     * @param photometricError
     */
    public final void setPhotometricError(Float photometricError) {
        this.photometricError = photometricError;
    }

    /**
     * Gets the String property <b>magnitudeTranslationFormula</b>.
     *
     * @return String
     */
    public final String getMagnitudeTranslationFormula() {
        return (magnitudeTranslationFormula);
    }

    /**
     * Sets the String property <b>magnitudeTranslationFormula</b>.
     *
     * @param magnitudeTranslationFormula
     */
    public final void setMagnitudeTranslationFormula(String magnitudeTranslationFormula) {
        this.magnitudeTranslationFormula = magnitudeTranslationFormula;
    }

    /**
     * Gets the String property <b>magnitudeCorrection</b>.
     *
     * @return String
     */
    public final String getMagnitudeCorrection() {
        return (magnitudeCorrection);
    }

    /**
     * Sets the String property <b>magnitudeCorrection</b>.
     *
     * @param magnitudeCorrection
     */
    public final void setMagnitudeCorrection(String magnitudeCorrection) {
        this.magnitudeCorrection = magnitudeCorrection;
    }

    /**
     * Gets the XmlDistortionField property <b>distortionField</b>.
     *
     * @return XmlDistortionField
     */
    public final XmlDistortionField getDistortionField() {
        return (distortionField);
    }

    /**
     * Sets the XmlDistortionField property <b>distortionField</b>.
     *
     * @param distortionField
     */
    public final void setDistortionField(XmlDistortionField distortionField) {
        this.distortionField = distortionField;
        distortionField.setParentRNode(this);
    }

    /**
     * Gets the String property <b>filter</b>.
     *
     * @return String
     */
    public final String getFilter() {
        return (filter);
    }

    /**
     * Sets the String property <b>filter</b>.
     *
     * @param filter
     */
    public final void setFilter(String filter) {
        this.filter = filter;
    }

    /**
     * Gets the String property <b>chip</b>.
     *
     * @return String
     */
    public final String getChip() {
        return (chip);
    }

    /**
     * Sets the String property <b>chip</b>.
     *
     * @param chip
     */
    public final void setChip(String chip) {
        this.chip = chip;
    }

    /**
     * Gets the String property <b>instruments</b>.
     *
     * @return String
     */
    public final String getInstruments() {
        return (instruments);
    }

    /**
     * Sets the String property <b>instruments</b>.
     *
     * @param instruments
     */
    public final void setInstruments(String instruments) {
        this.instruments = instruments;
    }

    /**
     * Gets the String property <b>baseCatalog</b>.
     *
     * @return String
     */
    public final String getBaseCatalog() {
        return (baseCatalog);
    }

    /**
     * Sets the String property <b>baseCatalog</b>.
     *
     * @param baseCatalog
     */
    public final void setBaseCatalog(String baseCatalog) {
        this.baseCatalog = baseCatalog;
    }

    /**
     * Gets the XmlAstrometry property <b>astrometry</b>.
     *
     * @return XmlAstrometry
     */
    public final XmlAstrometry getAstrometry() {
        return (astrometry);
    }

    /**
     * Sets the XmlAstrometry property <b>astrometry</b>.
     *
     * @param astrometry
     */
    public final void setAstrometry(XmlAstrometry astrometry) {
        this.astrometry = astrometry;
        astrometry.setParentRNode(this);
    }

    /**
     * Gets the XmlPhotometry property <b>photometry</b>.
     *
     * @return XmlPhotometry
     */
    public final XmlPhotometry getPhotometry() {
        return (photometry);
    }

    /**
     * Sets the XmlPhotometry property <b>photometry</b>.
     *
     * @param photometry
     */
    public final void setPhotometry(XmlPhotometry photometry) {
        this.photometry = photometry;
        photometry.setParentRNode(this);
    }

    /**
     * Gets the XmlReversedImage property <b>reversedImage</b>.
     *
     * @return XmlReversedImage
     */
    public final XmlReversedImage getReversedImage() {
        return (reversedImage);
    }

    /**
     * Sets the XmlReversedImage property <b>reversedImage</b>.
     *
     * @param reversedImage
     */
    public final void setReversedImage(XmlReversedImage reversedImage) {
        this.reversedImage = reversedImage;
        reversedImage.setParentRNode(this);
    }

    /**
     * Gets the XmlSbigImage property <b>sbigImage</b>.
     *
     * @return XmlSbigImage
     */
    public final XmlSbigImage getSbigImage() {
        return (sbigImage);
    }

    /**
     * Sets the XmlSbigImage property <b>sbigImage</b>.
     *
     * @param sbigImage
     */
    public final void setSbigImage(XmlSbigImage sbigImage) {
        this.sbigImage = sbigImage;
        sbigImage.setParentRNode(this);
    }

    /**
     * Gets the XmlUnofficial property <b>unofficial</b>.
     *
     * @return XmlUnofficial
     */
    public final XmlUnofficial getUnofficial() {
        return (unofficial);
    }

    /**
     * Sets the XmlUnofficial property <b>unofficial</b>.
     *
     * @param unofficial
     */
    public final void setUnofficial(XmlUnofficial unofficial) {
        this.unofficial = unofficial;
        unofficial.setParentRNode(this);
    }

    /**
     * Gets the XmlStarCount property <b>starCount</b>.
     *
     * @return XmlStarCount
     */
    public final XmlStarCount getStarCount() {
        return (starCount);
    }

    /**
     * Sets the XmlStarCount property <b>starCount</b>.
     *
     * @param starCount
     */
    public final void setStarCount(XmlStarCount starCount) {
        this.starCount = starCount;
        starCount.setParentRNode(this);
    }

    /**
     * Gets the String property <b>note</b>.
     *
     * @return String
     */
    public final String getNote() {
        return (note);
    }

    /**
     * Sets the String property <b>note</b>.
     *
     * @param note
     */
    public final void setNote(String note) {
        this.note = note;
    }

    /**
     * Gets the IRNode property <b>parentRNode</b>.
     *
     * @return IRNode
     */
    public final IRNode getParentRNode() {
        return (parentRNode);
    }

    /**
     * Sets the IRNode property <b>parentRNode</b>.
     *
     * @param parentRNode
     */
    public final void setParentRNode(IRNode parentRNode) {
        this.parentRNode = parentRNode;
    }

    /**
     * Gets child RNodes.
     *
     * @return IRNode[]
     */
    public IRNode[] getRNodes() {
        java.util.List classNodes = new java.util.ArrayList();
        classNodes.add(image);
        classNodes.add(sizeValue);
        if (exposure != null) {
            classNodes.add(exposure);
        }
        classNodes.add(center);
        classNodes.add(fov);
        classNodes.add(rotation);
        classNodes.add(pixelSize);
        if (astrometricError != null) {
            classNodes.add(astrometricError);
        }
        if (distortionField != null) {
            classNodes.add(distortionField);
        }
        if (astrometry != null) {
            classNodes.add(astrometry);
        }
        if (photometry != null) {
            classNodes.add(photometry);
        }
        if (reversedImage != null) {
            classNodes.add(reversedImage);
        }
        if (sbigImage != null) {
            classNodes.add(sbigImage);
        }
        if (unofficial != null) {
            classNodes.add(unofficial);
        }
        if (starCount != null) {
            classNodes.add(starCount);
        }
        IRNode[] nodes = new IRNode[classNodes.size()];
        return ((IRNode[])classNodes.toArray(nodes));
    }

    /**
     * Gets the RContext property <b>rContext</b>.
     *
     * @return RContext
     */
    public final RContext getRContext() {
        return (rContext);
    }

    /**
     * Sets the RContext property <b>rContext</b>.
     *
     * @param rContext
     */
    public final void setRContext(RContext rContext) {
        this.rContext = rContext;
        IRNode[] contextRNodes = getRNodes();
        for (int i = 0;i < contextRNodes.length;i++) {
            contextRNodes[i].setRContext(rContext);
        }
    }

    /**
     * Gets the property "rContext" which is resolved recursively.
     *
     * @return RContext
     */
    public RContext getRContextResolved() {
        if (rContext != null) {
            return (rContext);
        }
        if (parentRNode == null) {
            return (null);
        }
        return (parentRNode.getRContextResolved());
    }

    /**
     * Tests if a Element <code>element</code> is valid
     * for the <code>XmlInformation</code>.
     *
     * @param element
     * @return boolean
     */
    public static boolean isMatch(Element element) {
        String tagName = element.getTagName();
        if (!"information".equals(tagName)) {
            return (false);
        }
        RStack target = new RStack(element);
        Element child;
        child = target.peekElement();
        if (child != null) {
            if ("path".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (!XmlImage.isMatchHungry(target)) {
            return (false);
        }
        if (!XmlSize.isMatchHungry(target)) {
            return (false);
        }
        child = target.peekElement();
        if (child != null) {
            if ("date".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (XmlExposure.isMatchHungry(target)) {
        }
        child = target.peekElement();
        if (child != null) {
            if ("observer".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (!XmlCenter.isMatchHungry(target)) {
            return (false);
        }
        if (!XmlFov.isMatchHungry(target)) {
            return (false);
        }
        if (!XmlRotation.isMatchHungry(target)) {
            return (false);
        }
        if (!XmlPixelSize.isMatchHungry(target)) {
            return (false);
        }
        child = target.popElement();
        if (child == null) {
            return (false);
        }
        if (!"limiting-mag".equals(child.getTagName())) {
            return (false);
        }
        child = target.peekElement();
        if (child != null) {
            if ("upper-limit-mag".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (XmlAstrometricError.isMatchHungry(target)) {
        }
        child = target.peekElement();
        if (child != null) {
            if ("photometric-error".equals(child.getTagName())) {
                target.popElement();
            }
        }
        child = target.peekElement();
        if (child != null) {
            if ("magnitude-translation-formula".equals(child.getTagName())) {
                target.popElement();
            }
        }
        child = target.peekElement();
        if (child != null) {
            if ("magnitude-correction".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (XmlDistortionField.isMatchHungry(target)) {
        }
        child = target.peekElement();
        if (child != null) {
            if ("filter".equals(child.getTagName())) {
                target.popElement();
            }
        }
        child = target.peekElement();
        if (child != null) {
            if ("chip".equals(child.getTagName())) {
                target.popElement();
            }
        }
        child = target.peekElement();
        if (child != null) {
            if ("instruments".equals(child.getTagName())) {
                target.popElement();
            }
        }
        child = target.popElement();
        if (child == null) {
            return (false);
        }
        if (!"base-catalog".equals(child.getTagName())) {
            return (false);
        }
        if (XmlAstrometry.isMatchHungry(target)) {
        }
        if (XmlPhotometry.isMatchHungry(target)) {
        }
        if (XmlReversedImage.isMatchHungry(target)) {
        }
        if (XmlSbigImage.isMatchHungry(target)) {
        }
        if (XmlUnofficial.isMatchHungry(target)) {
        }
        if (XmlStarCount.isMatchHungry(target)) {
        }
        child = target.peekElement();
        if (child != null) {
            if ("note".equals(child.getTagName())) {
                target.popElement();
            }
        }
        if (!target.isEmptyElement()) {
            return (false);
        }
        return (true);
    }

    /**
     * Tests if elements contained in a Stack <code>stack</code>
     * is valid for the <code>XmlInformation</code>.
     * This mehtod is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     * @return boolean
     */
    public static boolean isMatch(RStack stack) {
        Element element = stack.peekElement();
        if (element == null) {
            return (false);
        }
        return (isMatch(element));
    }

    /**
     * Tests if elements contained in a Stack <code>stack</code>
     * is valid for the <code>XmlInformation</code>.
     * This method consumes the stack contents during matching operation.
     * This mehtod is supposed to be used internally
     * by the Relaxer system.
     *
     * @param stack
     * @return boolean
     */
    public static boolean isMatchHungry(RStack stack) {
        Element element = stack.peekElement();
        if (element == null) {
            return (false);
        }
        if (isMatch(element)) {
            stack.popElement();
            return (true);
        } else {
            return (false);
        }
    }
}
